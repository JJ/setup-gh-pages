{"name":"Tuto-google-apps","tagline":"Tutorial de Google Apps para el centro de profesores","body":"Tutorial de Google App Script\r\n=============================\r\n\r\n\r\n## Empecemos por el principio\r\n\r\n[Software as a Service o SaaS](http://es.wikipedia.org/wiki/Software_como_servicio)\r\nes un modelo de uso de software en el cual parte, o toda, la lógica de\r\nla aplicación está en la web. Podemos denominar SaaS tanto a las\r\napliaciones ricas de Internet (con un interfaz como el de cualquiera\r\naplicación de escritorio) como a aplicaciones *clásicas* basadas en\r\nformularios, pero en propiedad se corresponde más a las primeras.\r\n\r\nLas aplicaciones en modo SaaS están sustituyendo hoy en día a la\r\nmayoría de las aplicaciones de escritorio e, igual que en estas el\r\nmodelo habitual (en aplicaciones privativas) es de pago por licencia,\r\nen el modelo SaaS se suele pagar por su implantación y,\r\nposteriormente, por uso en diferentes modalidades, tarifa plana o por\r\nintensidad de uso.\r\n\r\nMuchas aplicaciones, además, son un *marco* sobre el cual se pueden\r\ndesarrollar funcionalidades adicionalees. A modo de sistema operativo,\r\nofrecen una serie de servicios a los que se puede acceder a modo de\r\n*plugins* o *addons*. Los lenguajes usados para esto son generalmente\r\nJavascript u otros lenguajes *empotrados* como Lua, aunque algunos\r\nservicios pueden tener lenguajes propios o simplemente no permitir\r\nnuevas funcionalidades.\r\n\r\nLas que lo permiten, como Google Drive, se convierten en plataformas\r\ndonde se pueden desarrollar verdaderas aplicaciones.\r\n\r\n> Discutir diferentes SaaS de uso habitual y sus ventajas e\r\n> inconvenientes frente a aplicaciones de escritorio.\r\n\r\n## Intro a Google Drive\r\n\r\n[Google Drive](http://drive.google.com) es una suite ofimática y de\r\naplicaciones de Google que incluye las aplicaciones ofimáticas\r\nbásicas, más una serie de aplicaciones conectables como GeoGebra,\r\nMindMeister e incluso un corregidor de ortografía, estilo y\r\ngramática. Muchas de ellas son gratuitas, pero en realidad se trata de\r\nuna nueva plataforma de distribución y de creación de software en la\r\nnube.\r\n\r\nComo se ha visto anteriormente, a un nivel muy básico una aplicación\r\nen la nube es simplemente un formulario. Los formularios de Google\r\nDrive están conectados a una hoja de cálculo y automáticamente crean\r\ngráficos con las respuestas.\r\n\r\nDentro de la hoja de cálculo donde se depositan las respuestas, se\r\npueden crear tablas dinámicas. Estas tablas dinámicas son fáciles de\r\ncrear y, en muchos casos, permiten realizar informes de forma\r\ndinámica.\r\n\r\n> Crear un formulario que permita, por ejemplo, introducir respuestas\r\n> a una encuesta. Examinar la hoja de respuestas y crear un informe de\r\n> tabla dinámica (Datos->Informe de Tabla dinámica)\r\n\r\nUna de las aplicaciones más desconocidas y más útiles son las Tablas\r\nDinámicas de Google (o *Fusion Tables*). Se puede usar como punto de\r\npartida una hoja de cálculo qeu tengamos almacenada, pero tiene\r\ntambién una serie de demos que muestran lo que es capaz de\r\nhacer. Aparte de presentar la información de la hoja de diferentes\r\nformas, es capaz de situarla sobre un mapa y de crear todo tipo de\r\nvisualizaciones sobre la misma.\r\n\r\nLo interesante de todas estas aplicaciones es que van a ser accesibles\r\ndesde los *scripts* y por tanto podremos trabajar con ellas\r\ndinámicamente o acceder a unas desde otras, usando todas sus funciones\r\ncomo si de una librería se tratara. Lo veremos a continuación, después de ver un par de cosas, la primera de las cuales es\r\n\r\n## El modelo de objetos\r\n\r\nUn sistema operativo incluye una serie de llamada que permite a los\r\nprogramas que se ejecutan sobre él acceder a las funciones del\r\nsistema: abrir y cerrar ficheros, reservar memoria y todas las\r\noperaciones de mayor o menor nivel.\r\n\r\nLos entornos de operación modernos incluyen una gama de posibiliades\r\nmucho mayor que el simple sistema operativo; también cambian de\r\nparadigma del procedural al orientado a objetos; en general, los\r\nsistemas operativos u entornos gráficos modernos incluyen un modelo de\r\nobjetos (OM) al que se puede acceder desde el lenguaje preferido y,\r\npor supuesto, desde cualquier otra aplicación a la que se exponga el\r\ninterfaz de programación (API). El navegador tiene un\r\n[DOM](http://es.wikipedia.org/wiki/Document_Object_Model), un modelo\r\nde objetos para documentos, que incluye una serie de objetos ya\r\ninstanciados como `document` o `window`.\r\n\r\nGeneralmente, un SaaS extensible como las Google Apps tienen una serie\r\nde objetos que permiten usar los llamados\r\n[servicios](https://developers.google.com/apps-script/guides/services/)\r\nde Google Apps. Todas las aplicaciones básicas y avanzadas tienen uno,\r\ny a veces varios objetos, y estos servicios se suelen llamar\r\n`AlgoApp`. Por ejemplo, Google Drive tiene\r\n[`DriveApp`](https://developers.google.com/apps-script/reference/drive/)\r\ny las hojas de cálculo la\r\n[`SpreadsheetApp`](https://developers.google.com/apps-script/reference/spreadsheet/spreadsheet-app). Todos\r\nestos objetos están instanciados y accesibles a todos los scripts que\r\nvayamos a usar. Pero antes, tendremos que aprender sobre los\r\n\r\n> Buscar los objetos correspondientes a las diferentes aplicaciones de\r\n> Google Drive. ¿Cómo se llaman? ¿Cuantos tiene cada uno? \r\n\r\n## Métodos de autenticación\r\n\r\nCuando se trabaja en la nube se está trabajando con un interfaz de\r\naplicación, un API, igual que en el sistema operativo; en éste hay una\r\njerarquía de privilegios que te permiten activar, o no, diferentes\r\nfunciones y esos privilegios afectan por un lado a los usuarios y por\r\notro lado a los programas. Un usuario *autoriza* a un programa a\r\nejecutarse y acceder a sus recursos (sistema de ficheros, la red)\r\nsimplemente ejecutándolo. El permiso es implícito.\r\n\r\nSin embargo, en la nube el entorno es un poco más complicado. Primero,\r\nporque muchos programas se ejecutan también desde la misma nube y el\r\nconsiderar que hay una autorización implícita puede ser un poco\r\npeligroso. Segundo, porque los recursos están compartimentalizados y\r\nse puede decidir de forma granular a qué recursos se tiene acceso.\r\n\r\nPor eso generalmente se usa, igual que en el móvil cuando se instala\r\nuna aplicación, un proceso de autorización explícita; en casi todos\r\nlos casos se usa un sistema llamado\r\n[OAuth2](https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization). En\r\nla práctica, eso significa que hay dos conjuntos de claves\r\n\r\n* Una clave y un *secreto* por aplicación.\r\n* Una clave y un *secreto* por usuario que autorice.\r\n\r\nPor eso se suele hacer un sistema de autorización en dos pasos: en un\r\nprimer paso se descargan (generalmente del portal del desarrollador)\r\nla clave y el secreto y, cada vez que se accede a un nuevo usuario,\r\neste tiene que autorizarlo explícitamente, con lo que le *concede* a\r\nla aplicación la segunda clave y secreto.\r\n\r\nDependiendo del sistema que usemos, esto habrá que hacerlo y\r\nalmacenarlo por parte de nuestro programa. En el caso de Google App,\r\nsimplemente veremos que, cuando un usuario ejecuta por primera vez un\r\n*script*, tiene que autorizarlo. Lo que haremos justamente a\r\ncontinuación, cuando ejecutemos\r\n\r\n## Nuestro primer programa en la nube\r\n\r\n[Google Script](https://script.google.com/) es a la vez un entorno de\r\nprogramación que nos permite crear y ejecutar nuestro programa. Vamos\r\na por el primero, el clásico hola mundo. Si creamos un script en\r\nblanco, nos saldrá algo así; el entorno completa los nombres de las\r\nfunciones para aquellas que estén declaras:\r\n\r\n![Captura de pantalla del IDE](logger.png)\r\n\r\nEl primer programa se reduce a lo siguiente:\r\n\r\n```javascript\r\nfunction myFunction() {\r\n  Logger.log(\"¡Ola k ase!\");\r\n}\r\n```\r\n\r\nComo podéis ver, es una función que se tiene que llamar precisamente\r\nasí, `myFunction` y que no recibe ningún parámetro. Es Javascript, que\r\nes el lenguaje de *macros* de este entorno. Esta función será el\r\nequivalente al `main` de otros lenguajes: es la función que se llama\r\nal arrancar el script; puedes cambiarle el nombre, pero hasta que no\r\nguardes no podrás ejecutarla.\r\n\r\nY contiene una sola orden,\r\n`Logger.log(\"¡Ola k\r\nase!\");`. [`Logger` es uno de los objetos estándar de GAS](https://developers.google.com/apps-script/reference/base/logger),\r\ndisponible para todos y cada uno de los scripts que usemos y es un\r\nregistro de las acciones de cada programa. No nos queda más remedio\r\nque usar esto para salida, al menos para empezar. Los *scripts* en GAS\r\nno tienen salida estándar y por tanto no pueden simplemente usar el\r\n`writeln` de JS o el `console.log` (sinceramente, esto no lo he\r\nprobado). `log` añade una línea a ese registro, simplemente.\r\n\r\nSe puede ejecutar directamente con la flechita que aparece al lado del\r\nbicho (que es, lo pillasteis, para depurar o desenbichar). Te pedirá\r\nque le asignes un nombre y luego se olvidará de que querías\r\nejecutarlo, así que luego lo ejecutas.\r\n\r\nY no pasa nada. Le das de nuevo a ejecutar. Sigue sin pasar nada. ¿Qué\r\nocurre? Nada. No, es broma. Ocurre que, efectivamente, donde pasa algo\r\nes en el registro, al que se accede dando a Control-Enter o al menú\r\nVer -> Registros. Saldrá algo así:\r\n\r\n![Registro de resultados](registro.png)\r\n\r\n> Escribir un script que escriba en el registro una tabla de\r\n> multiplicar de un número determinado.\r\n\r\nDesde los scripts tenemos también acceso a la librería estándar de\r\nJavascript. Por ejemplo, a `JSON`, la librería para procesar las\r\nestructuras de datos de JS y transformarlas a cadenas y viceversa.\r\n\r\n```javascript\r\n  var foo = [1,2,3, {clave: \"Valor\"}];\r\n  Logger.log(JSON.stringify(foo));\r\n``` \r\n\r\nLa segunda línea convierte a una cadena la estructura de datos\r\ncompleja `foo`, lo que puede ser útil a la hora de depurar una\r\naplicación *a la antigua*, imprimiendo variables aparte de \"Estoy por\r\naquí\", \"No debería estar aquí\", y todo eso.\r\n\r\nValga lo anterior como prueba de que la clase JSON está incluida en la\r\nlibrería estándar, aunque en realidad `Logger.log(foo)` haría\r\nexactamente lo mismo (con un resultado ligeramente diferente). No\r\n[todas las clases (objetos globales) de JS](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)\r\nestán presentes en el GAS, pero sí los principales. \r\n\r\n##Vamos a hacer algo\r\n\r\nEl script anterior no hace nada, pero es un ejemplo de un tipo de\r\nscript denominado\r\n[*standalone*](https://developers.google.com/apps-script/guides/standalone),\r\nútil principalmente para usar el sistema como plataforma de\r\ncómputo. Pero, como se ha visto antes, estos scripts son los\r\nequivalentes a los de `bash` o de cualquier intérprete de\r\ncomandos. Nos permiten acceder a lo que tenemos en el sistema. Por\r\nejemplo, a los ficheros que tengamos en Google Drive, como vamos a\r\nhacer a continuación. Por ejemplo, podemos buscar los ficheros que\r\ncorrespondan a un determinado criterio.\r\n\r\n```javascript\r\nfunction myFunction() {\r\n  var ficheros = DriveApp.getFiles();\r\n  while (ficheros.hasNext()) {\r\n    var este_fichero = ficheros.next();\r\n    Logger.log(este_fichero.getName());\r\n  }\r\n}\r\n```\r\n\r\nEste fichero es una transcripción directa del\r\n[ejemplo en la guía de referencia](https://developers.google.com/apps-script/reference/drive/). Simplemente\r\nlista el nombre de los ficheros que tengamos en drive. Usa `DriveApp`\r\ny una función de la misma (que aparecerá en un desplegable cuando lo\r\nescribamos), [`getFiles`](https://developers.google.com/apps-script/reference/drive/drive-app#getFiles%28%29) que, evidentemente, lo que devuelve es un *iterador* a los\r\nficheros que tengamos en el drive, [clase `FileIterator`](https://developers.google.com/apps-script/reference/drive/file-iterator). Por eso no se\r\nrecorre simplemente un array, sino que se usa la función `hasNext`\r\npara acceder al siguiente fichero de la lista; el bucle terminará\r\ncuando no haya más ficheros. El mismo iterador se usa también para\r\nrecuperar el siguiente elemento, `next` pasa el cursor al siguiente\r\nelemento del iterador y devuelve un objeto de tipo\r\n[`File`](https://developers.google.com/apps-script/reference/drive/file),\r\nusando la metáfora del *drive* o disco como contenedor de *ficheros*.\r\n\r\nEsto podemos complicarlo un poquito más:\r\n```javascript\r\nfunction colaboradores() {\r\n  var ficheros = DriveApp.getFiles();\r\n  var colaboradores = new Object;\r\n  var ficheros_array = new Object;\r\n  while (ficheros.hasNext()) {\r\n    var este_fichero = ficheros.next();\r\n    colaboradores[este_fichero] = este_fichero.getEditors();\r\n    Logger.log(colaboradores[este_fichero]);\r\n  }\r\n  \r\n}\r\n```\r\nEn este caso, lo que hacemos es usar una variable asociativa\r\n(`colaboradores`) para almacenar los editores que cada fichero tiene,\r\nusando otra de las funciones del objeto. Usamos Logger, pero tambien\r\npuede resultar útil otra función: Ver -> Transcripción de la\r\nejecución, que nos explicita qué se ha hecho en cada momento y cuanto\r\nha tardado cada ejecución, inclusive el objetivo final. Si tenemos\r\nmuchos ficheros puede tardar un rato; consultando en este registro\r\n(que está activo siempre) podemos ver qué es lo que lo ha\r\nretrasado. En concreto, en mi Drive tarda varios minutos en terminar\r\nde ejecutarse, y obtengo algo así:\r\n\r\n```\r\n[14-12-04 14:05:06:349 CET] (class).next() [0 segundos]\r\n[14-12-04 14:05:06:476 CET] File.getEditors() [0,126 segundos]\r\n[14-12-04 14:05:06:477 CET] Logger.log([[DriveUser], []]) [0 segundos]\r\n[14-12-04 14:05:06:477 CET] (class).hasNext() [0 segundos]\r\n[14-12-04 14:05:06:478 CET] (class).next() [0 segundos]\r\n[14-12-04 14:05:06:698 CET] File.getEditors() [0,22 segundos]\r\n[14-12-04 14:05:06:698 CET] Logger.log([[DriveUser], []]) [0 segundos]\r\n[14-12-04 14:05:06:699 CET] (class).hasNext() [0 segundos]\r\n[14-12-04 14:05:06:699 CET] (class).next() [0 segundos]\r\n[14-12-04 14:05:06:804 CET] File.getEditors() [0,105 segundos]\r\n[14-12-04 14:05:06:805 CET] Logger.log([[], []]) [0 segundos]\r\n[14-12-04 14:05:06:805 CET] (class).hasNext() [0 segundos]\r\n[14-12-04 14:05:06:805 CET] (class).next() [0 segundos]\r\n[14-12-04 14:05:06:936 CET] File.getEditors() [0,13 segundos]\r\n[14-12-04 14:05:06:937 CET] Logger.log([[DriveUser, DriveUser, DriveUser], []]) [0 segundos]\r\n[14-12-04 14:05:06:937 CET] (class).hasNext() [0 segundos]\r\n[14-12-04 14:05:06:938 CET] (class).next() [0 segundos]\r\n[14-12-04 14:05:07:149 CET] File.getEditors() [0,211 segundos]\r\n[14-12-04 14:05:07:150 CET] Logger.log([[], []]) [0 segundos]\r\n[14-12-04 14:05:07:151 CET] (class).hasNext() [0 segundos]\r\n[14-12-04 14:05:07:151 CET] (class).next() [0 segundos]\r\n[14-12-04 14:05:07:340 CET] File.getEditors() [0,188 segundos]\r\n[14-12-04 14:05:07:340 CET] Logger.log([[], []]) [0 segundos]\r\n[14-12-04 14:05:07:341 CET] (class).hasNext() [0 segundos]\r\n[14-12-04 14:05:07:348 CET] Ejecución correcta [325.825 segundos de tiempo de ejecución total]\r\n```\r\nComo se ve, cada petición de getEditor tarda un ratico, un quinto de\r\nsegundo, lo que hace que al final tarde todo casi cinco\r\nminutos. Cuidado, por tanto, con este tipo de peticiones, sobre todo\r\nsi tiene uno que esperar al resultado, porque pueden emplear una buena\r\ncantidad de tiempo. Por otro lado, si miramos el resultado es un poco\r\ndecepcionante, porque aparece sólo DriveUser, así que tendremos que\r\nmodificarlo para que nos dé el nombre de usuario; al menos con esto\r\nsabemos cuantos colaboradores hay:\r\n\r\n```javascript\r\nfunction colaboradores() {\r\n  var ficheros = DriveApp.getFiles();\r\n  var colaboradores = new Object;\r\n  var ficheros_array = new Object;\r\n  while (ficheros.hasNext()) {\r\n    var este_fichero = ficheros.next();\r\n    colaboradores[este_fichero] = este_fichero.getEditors();\r\n    Logger.log(colaboradores[este_fichero].map( function (ed) {\r\n      ed.getEmail();\r\n    }));\r\n  }\r\n  \r\n  var ficheros_por_colaboradores = Objectk.dreys(colaboradores.).sort( compara_num_colaboradores );\r\n  for ( var i in ficheros_por_colaboradores ) {\r\n    Logger.log( { i : colaboradores[ficheros_por_colaboradores[i]].length });\r\n  } \r\n\r\n               \r\n}\r\n\r\nfunction compara_num_colaboradores( a, b ) {\r\n  return colaboradores[a].length - colaboradores[b].length;\r\n}\r\n```\r\n\r\nDe camino, también ordenamos los ficheros por número de colaboradores,\r\nlo que hace la función `compara_num_colaboradores`. Aquí hay un poco\r\nde programación funcional en JS, además por partida doble. Primero,\r\nusamos `map`, una función que aplica, a su vez, una función a cada uno\r\nde los elementos de un array. En este caso es un *closure* o función\r\nanónima, básicamente una función que declaramos sobre la\r\nmarcha. También se pasa una función así a `sort`: es la función que se\r\nusa para clasificar y que en este caso lo hace según el número de\r\ncolaboradores (longitud del array).\r\n\r\n> Realizar un script que recupere el *peso* de cada uno de los\r\n> ficheros almacenados en el Drive y liste sólo los PDFs.\r\n\r\n##Trabajando con varios documentos\r\n\r\nFinalmente (por hoy) podemos trabajar con varios documentos. Cada tipo\r\nde documento tiene un servicio y, por ejemplo, podemos almacenar los\r\ncolaboradores en una hoja de cálculo para más adelante trabajar con\r\nellos:\r\n\r\n```javascript\r\nfunction colaboradores() {\r\n  var ficheros = DriveApp.getFiles();\r\n  var hoja_destino = SpreadsheetApp.openById('1-D5cKkXalIdp5M2fhybqEtf5eQuFpBSTwM7HgsKgwfM');\r\n  var colaboradores = new Object;\r\n  var ficheros_array = new Object;\r\n  while (ficheros.hasNext()) {\r\n    var este_fichero = ficheros.next();\r\n    colaboradores[este_fichero] = este_fichero.getEditors();\r\n    hoja_destino.appendRow( [este_fichero, colaboradores[este_fichero] ]);\r\n  }\r\n \r\n}\r\n```\r\n\r\nAquí usamos `SpreadsheetApp` y abrimos usando el ID (una parte del URL\r\nque se ve en la barra del navegador). El programa es similar al\r\nanterior, pero en este caso usamos el objeto `hoja_destino` para\r\nañadirle una fila `append_row` con el nombre del fichero y los\r\ncolaboradores.\r\n\r\n> *Contar* el peso de los ficheros en un  [documento de texto](https://developers.google.com/apps-script/reference/document/), de esta\r\n> forma: \"El fichero x tiene y megas.\".\r\n\r\n(Aviso: los programas de arriba no están del todo depurados, así que\r\ntu camino puede variar).\r\n\r\n\r\n## Concluyendo\r\n\r\nGoogle Drive permite tomar un primer contacto con el desarrollo de\r\naplicaciones en la nube, al nivel *SaaS*. Los scripts pueden ir desde\r\nlo simple, hasta lo muy complejo que se puede publicar en la tienda de\r\napps, convirtiéndose también en un nuevo modo de distribución de\r\nsoftware. Y básicamente lo que hay que conocer es JavaScript y un poco\r\ndel modelo de objetos.\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}